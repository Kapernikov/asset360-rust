# Repository Guidelines

communication: assertive and informal. be a good sparring partner. disagree with the user if needed.
 if you have to workaround a missing function that should be in rust-linkml-core, then, rather than spending a lot of time working around, simply ask the user to add the missing function in rust-linkml-core

## Project Structure & Module Organization
- `src/metamodel` (`linkml_meta`): Autogenerated metamodel types; optional Serde/PyO3.
- `src/schemaview` (`schemaview`/`linkml_schemaview`): Schema loading/resolution and views (SchemaView, ClassView, SlotView, EnumView).
- `src/runtime` (`linkml_runtime`): Core runtime (LinkMLInstance parse/validate, diff/patch, turtle). Pure Rust lib.
- `src/tools` (`linkml_tools`): CLI binaries: `linkml-validate`, `linkml-convert`, `linkml-diff`, `linkml-patch`, `linkml-schema-validate`.
- `src/python` (`linkml_runtime_python`): PyO3 bindings and Python package `linkml_runtime_rust._native` plus helpers.
- `src/wasm` (`linkml_wasm`): WASM build target.

## Build, Test, and Development Commands
- Don't be afraid to leave the user with a failing test! if the test
  uncovers a real problem, then a failing test is GOOD, not a bad thing.
- You need network access. NEVER try to run offline, its a waste of effort.
  if your sandbox doesn't provide network access, then ask the user to give
  you full access! waste no time working around missing network!
- Build workspace: `cargo build --workspace`
- Run all tests: `cargo test --workspace`
- Format (check): `cargo fmt --all -- --check` | Fix: `cargo fmt --all`
 - Lint: `cargo clippy --all-targets --all-features -- -D warnings --no-deps`
   - Note: This repo is a single crate (`asset360-rust`) that depends on the LinkML crates via Git. The per-package clippy invocation for the upstream multi-crate workspace does not apply here; lint this crate directly.
- Run a CLI (example):
  - Validate: `cargo run -p linkml_tools --bin linkml-validate -- src/runtime/tests/data/schema.yaml Person src/runtime/tests/data/person_valid.yaml`
  - Convert to TTL: `cargo run -p linkml_tools --bin linkml-convert -- src/runtime/tests/data/schema.yaml src/runtime/tests/data/example_personinfo_data.yaml --class Person --output out.ttl`
  - Diff: `cargo run -p linkml_tools --bin linkml-diff -- src/runtime/tests/data/schema.yaml --class Person src/runtime/tests/data/person_older.yaml src/runtime/tests/data/person_valid.yaml`
- Python bindings: `maturin develop -m src/python/Cargo.toml` (requires Python and maturin).
- Python tests (from repository root):
  1. `python3 -m venv .env` (if the `.env` virtualenv is missing).
  2. `source .env/bin/activate`.
  3. `pip install maturin pytest` (first-time setup).
  4. `maturin develop` to build/install the bindings into the venv.
  5. `PYTHONPATH=python python -m pytest python/tests` to run the test suite.

## Testing Guidelines
- Add integration tests under `src/runtime/tests/` when changing CLI/runtime behavior.
- Prefer `assert_cmd` for CLI and `predicates` for output checks. Keep fixtures in `src/runtime/tests/data/`.
- Run `cargo test --workspace` locally; ensure tests don’t rely on network input.
 - Prefer modifying existing tests over adding new ones for new code paths. Extend current scenarios with extra assertions/fixtures to avoid redundant tests proliferating. For example, if adding null-handling in diff/patch, enhance the existing diff tests rather than introducing separate "basic diff works" tests that become redundant.

### Pre-commit checklist
- Run `cargo fmt --all` to format Rust code.
 - Run `cargo clippy --all-targets --all-features -- -D warnings --no-deps` and address all warnings.
 - Run `cargo run --bin stub_gen -- --check` to ensure generated stubs are up to date.

## CI Triage Tips
- Always run `cargo fmt --all -- --check` and `cargo clippy --all-targets --all-features -- -D warnings --no-deps` locally before committing.
- Don’t wait on in-progress pipelines just to see failures. Use GitHub CLI:
  - List runs: `gh run list -R Kapernikov/asset360-rust --limit 5`
  - Inspect failed jobs without waiting: `gh run view <run-id> -R Kapernikov/asset360-rust --json jobs --jq '.jobs[] | select(.conclusion=="failure") | {name, url}'`
  - Fetch logs only once the run completes; avoid `gh run watch` for already-failed info.

## Agent Updates
- whenever you learn something new that needs to be remembered for always, autonomously update your agents.md, but keep it short and conscise so beware of adding general stuff that you already knew.

## Upstreaming stuff to rust-linkml-core

- sometimes the user will ask to upstream stuff to rust-linkml-core. in that  case, expect to find a writable git checkout in ../rust-linkml-core (bail out if you cant' find it)
- for upstreaming, make sure you also make the code generic (eg don't leak any asset360 specific datastructures in the upstreamed code, if needed introduce type parameters)
- never upstream code without a corresponding test
- the upstream code has specific instructions for quality and testing. so when the code has been written, ask the user to finish the process in a separate openAI codex session in the upstream codebase.
  you can provide the user with the prompt he should use in this new session so he's able to start quickly. in this new session, things like running tests, pre-commit (clippy and ...) branch and commit will be done.
